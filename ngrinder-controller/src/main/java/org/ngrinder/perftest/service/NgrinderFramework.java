/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.ngrinder.perftest.service;

import com.google.protobuf.ByteString;
import freemarker.template.utility.StringUtil;
import org.apache.mesos.*;
import org.ngrinder.infra.config.Config;
import org.ngrinder.infra.schedule.ScheduledTaskService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static org.ngrinder.common.util.ExceptionUtils.processException;

/**
 * Mesos framework of ngrinder.
 * <p/>
 * This class register the framework to mesos master. When nGrinder need more agents, the framework will launch tasks.
 * Task is sent to mesos slave to run. One mesos slave will only run one task, so one mesos slave will only run one
 * ngrinder agent.
 * <p/>
 * The task includes the ngrinder agent docker image. Mesos slave will automatically download the docker image and run it.
 * <p/>
 * this class implements the interface Scheduler
 * <p/>
 * Mesos slave should support docker, and should install docker before.
 *
 *
 * @author binju
 * @since 3.4
 */
@Component
public class NgrinderFramework implements Scheduler {

    private static final Logger LOG = LoggerFactory.getLogger(NgrinderFramework.class);

    @Autowired
    Config config;

    @Autowired
    ScheduledTaskService scheduledTaskService;

    @Autowired
    PerfTestService perfTestService;

    private boolean isMesosFrameworkStart = false;
    private boolean nativeLibraryLoaded = false;
    private MesosSchedulerDriver driver = null;

    private Map<String, String> slaveAttributes = null;
    private LinkedHashMap<String, Integer> requests = null;
    private Map<String, Result> results = null;

    private int mesosAllowedAgentCount = 0;
    private long calculateMesosAllowedAgentCountTimeStamp = 0;

    /**
     * If the agent.auto_scale_type is mesos, we should register the framework to mesos master.
     * And add system config file modification listener.
     */
    @PostConstruct
    public void init() {

        config.addSystemConfListener(initDynamicAgentMesosTypeListener());

        registerNgrinderFramework();
    }

    /**
     *  If the system config file is changed, this function will be called.
     *
     * @return PropertyChangeListener
     */
    private PropertyChangeListener initDynamicAgentMesosTypeListener(){
        return new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                registerNgrinderFramework();
            }
        };
    }

    /**
     * load the mesos Native mesos library. The mesos library is generated by making the mesos source code.
     */
    private void loadNativeLibrary() {
        if(!nativeLibraryLoaded) {
            // we attempt to load the library from the given path.
            try {
                MesosNativeLibrary.load(config.getAgentAutoScaleMesosLibPath());
            } catch (UnsatisfiedLinkError error) {
                LOG.error("Failed to load native Mesos library from '" + config.getAgentAutoScaleMesosLibPath() +
                        "': " + error.getMessage());

                throw processException("Failed to load native Mesos library", error);
            }
            nativeLibraryLoaded = true;
        }
    }

    /**
     * Start framework: parse the configured slave attributes, load the mesos native library
     * and register the framework info to mesos master.
     *
     */
    public void startFramework(){

        parseSlaveAttributes();
        loadNativeLibrary();

        if (driver == null) {
            Protos.FrameworkInfo frameworkInfo = Protos.FrameworkInfo.newBuilder()
                    .setUser(config.getAgentAutoScaleMesosUser() == null ? "" : config.getAgentAutoScaleMesosUser())
                    .setName(config.getAgentAutoScaleMesosFrameworkName())
                    .setPrincipal(config.getAgentAutoScaleMesosPrincipal() == null ? "" : config.getAgentAutoScaleMesosPrincipal())
                    .setWebuiUrl("http://" + config.getAgentAutoScaleControllerIP() + ":" + config.getAgentAutoScaleControllerPort())
                    .build();

            LOG.debug("Start register ngrinder framework to mesos master!");

            isMesosFrameworkStart = true;
            if (config.getAgentAutoScaleMesosPrincipal() != null && config.getAgentAutoScaleMesosSecret() != null) {
                Protos.Credential credential = Protos.Credential.newBuilder()
                        .setPrincipal(config.getAgentAutoScaleMesosPrincipal())
                        .setSecret(ByteString.copyFromUtf8(config.getAgentAutoScaleMesosSecret()))
                        .build();

                driver = new MesosSchedulerDriver(this, frameworkInfo, config.getAgentAutoScaleMesosMaster(), credential);
            }
            else {
                driver = new MesosSchedulerDriver(this, frameworkInfo, config.getAgentAutoScaleMesosMaster());
            }

            Protos.Status runStatus = driver.run();

            if (runStatus != Protos.Status.DRIVER_STOPPED) {
                LOG.debug("The Mesos driver was aborted! Status code: " + runStatus.getNumber());
            }

            LOG.debug("ngrinder framework is stopped");

            driver = null;
            isMesosFrameworkStart = false;
        }
    }

    /**
     * If the framework is not started and mesos is enabled, initialize and register framework to mesos master.
     * If framework is started and mesos is not enabled, stop the framework.
     * If framework is started and mesos is enabled, parse the attributes info.
     *
     */
    public void registerNgrinderFramework() {

        if (!isMesosFrameworkStarted() && config.isAgentAutoScaleMesosEnabled()) {
            slaveAttributes = new ConcurrentHashMap<String, String>();
            requests = new LinkedHashMap<String, Integer>();
            results = new ConcurrentHashMap<String, Result>();

            Runnable registerRunable = new Runnable() {
                @Override
                public void run() {
                    startFramework();
                }
            };

            scheduledTaskService.runAsync(registerRunable);
        }
        else if (isMesosFrameworkStarted() && driver != null && !config.isAgentAutoScaleMesosEnabled()){
            driver.stop();
            driver = null;
            isMesosFrameworkStart = false;
        }
        else if (isMesosFrameworkStarted()) {
            parseSlaveAttributes();
        }
    }

    /**
     * If auto_scale_mesos_slave_attributes is configured, this function is used to parse the attributes. The Framework
     * will select the mesos slave according to these attributes.
     *
     */
    private void parseSlaveAttributes() {
        String salveAttrs = config.getAgentAutoScaleMesosSlaveAttributes();
        if (salveAttrs == null) {
            return;
        }

        String [] attrs = salveAttrs.split(";");
        for(String attr:attrs) {
            String [] values = attr.split(":");
            if (values.length == 2) {
                slaveAttributes.put(values[0], values[1]);
            }
        }
    }

    /**
     * check if the ngrinder framework has been registered to mesos master
     *
     * @return true or false
     */
    public boolean isMesosFrameworkStarted(){
        return isMesosFrameworkStart;
    }

    /**
     * Add the new request to LinkedHashMap<String, Integer> Requests.
     * I think mesos can create the required agents in 5 mins. If it is over 5 mins, I think some error occur.
     * So, remove the old request and add new request.
     * If we only add the new request once, the framework can't create enough agents for the test when some error occur.
     *
     * @param perfTestId perfTestIdentifier
     * @param requiredAgents the count of required agents
     */
    public void addNewRequest(String perfTestId, int requiredAgents){
        boolean isAddNewRequest = false;

        if(results.get(perfTestId) != null) {
            long timeThreshhold = System.currentTimeMillis() - results.get(perfTestId).getSchedulerTime();
            if (timeThreshhold > 5 * 60 *1000)
                isAddNewRequest = true;
        }
        else {
            isAddNewRequest = true;
        }


        if (isAddNewRequest && requests.containsKey(perfTestId)) {
            operateRequets(Operation.REMOVE, perfTestId, -1);
        }

        if (isAddNewRequest) {
            operateRequets(Operation.ADD, perfTestId, requiredAgents);
        }
    }

    @Override
    public void registered(SchedulerDriver driver, Protos.FrameworkID frameworkId, Protos.MasterInfo masterInfo) {
        LOG.debug("Framework registered! ID = " + frameworkId.getValue());
        LOG.debug("isMesosFrameworkStart = {}", isMesosFrameworkStart);
    }

    @Override
    public void reregistered(SchedulerDriver driver, Protos.MasterInfo masterInfo) {
        LOG.debug("Framework re-registered");
    }

    @Override
    public void disconnected(SchedulerDriver driver) {
        LOG.debug("Framework disconnected!");
    }

    /**
     * generate the task Id. It is composited by perfTestIdentifier and index
     *
     * @param perfTestId perfTestIdentifier
     * @return Protos.TaskID taskId
     */
    private Protos.TaskID getTaskId(String perfTestId){
        if(results.get(perfTestId) == null){
            return Protos.TaskID.newBuilder().setValue(perfTestId + "_" + 0).build();
        }
        else {
            return Protos.TaskID.newBuilder()
                    .setValue(perfTestId + "_" + results.get(perfTestId).getTasksOfPerfTest().size()).build();
        }
    }

    /**
     * Get the Mesos can support the MAX agent count. We can set the the Max value of dynamic agents in system.conf.
     * If the time is over 30 seconds that nGrinder can't receive offers from mesos master,
     * I think the mesos has no resource for nGrinder.
     *
     * @return mesosAllowedAgentCount or 0
     */
    public int getMesosAllowedAgentCount() {
        long timeDuration = System.currentTimeMillis() - calculateMesosAllowedAgentCountTimeStamp;
        if (timeDuration > 30 * 1000) {
            return 0;
        }
        else {
            return Math.min(mesosAllowedAgentCount, config.getAgentAutoScaleMaxNodes());
        }
    }

    /**
     * Get the agents count created by mesos
     *
     * @return int agents count
     */
    public int getMesosRunningAgentCount() {
        int mesosRunningAgentCount = 0;

        Iterator iterator = results.keySet().iterator();
        while(iterator.hasNext()) {
            String testId = iterator.next().toString();

            if (results.get(testId).getTasksOfPerfTest() != null) {
                mesosRunningAgentCount += results.get(testId).getTasksOfPerfTest().size();
            }
        }

        return mesosRunningAgentCount;
    }

    /**
     * Check the perfTest is still include in database. testId is got from the perfTestIdentifier.
     *
     * @param perfTestId perfTestIdentifier
     * @return true or false
     */
    private boolean isPerfTestExit(String perfTestId) {
        String [] str = StringUtil.split(perfTestId, '_');
        if (str.length == 3) {
            String id = str[str.length - 2];
            if (perfTestService.getOne(Long.parseLong(id)) == null) {
                LOG.debug("perfTestIdentifier = {} has been deleted from database", perfTestId);
                return true;
            }
        }

        return false;

    }

    /**
     * Match the offer's attributes and configured slaveAttributes in system config.
     *
     * @param offer offer
     * @return true or false
     */
    private boolean matchAttributes(Protos.Offer offer) {
        boolean slaveTypeMatch = true;

        if (slaveAttributes.size() == 0) {
            return slaveTypeMatch;
        }

        //get the offer's attribute
        Map<String, String> attributesMap = new ConcurrentHashMap<String, String>();
        for (Protos.Attribute attribute:offer.getAttributesList()) {
            attributesMap.put(attribute.getName(), attribute.getText().getValue());
        }

        Iterator iterator = slaveAttributes.keySet().iterator();
        while (iterator.hasNext()) {
            String key = iterator.next().toString();

            //If there is a single absent attribute then we should reject this offer.
            if (!(attributesMap.containsKey(key)
                    && attributesMap.get(key).equals(slaveAttributes.get(key)))) {
                slaveTypeMatch = false;
                break;
            }
        }

        return slaveTypeMatch;
    }

    /**
     * Create and launch the mesos task. The task includes the docker info.
     * Currently, one offer only run one task, all resources of offer is used by the task.
     *
     * @param offer offer
     * @param perfTestId perfTestIdentifier
     * @return Protos.TaskID taskId
     */
    private Protos.TaskID createMesosTask(Protos.Offer offer, String perfTestId) {

        Protos.TaskID taskId = getTaskId(perfTestId);

        LOG.debug("create a new task, task id = {}", taskId.getValue());

        Protos.Environment.Builder environmentBuilder = Protos.Environment.newBuilder();
        Protos.Environment.Variable.Builder variableBuilder = Protos.Environment.Variable.newBuilder();
        variableBuilder.setName("CONTROLLER_ADDR");
        variableBuilder.setValue(config.getAgentAutoScaleControllerIP()+":"+config.getAgentAutoScaleControllerPort());
        environmentBuilder.addVariables(variableBuilder);

        Protos.CommandInfo.Builder commandBuilder = Protos.CommandInfo.newBuilder();
        commandBuilder.setShell(false);
        commandBuilder.setEnvironment(environmentBuilder);

        Protos.ContainerInfo.Builder containerInfoBuilder = Protos.ContainerInfo.newBuilder();
        containerInfoBuilder.setType(Protos.ContainerInfo.Type.DOCKER);
        Protos.ContainerInfo.DockerInfo.Builder dockerInfoBuider = Protos.ContainerInfo.DockerInfo.newBuilder();
        dockerInfoBuider.setImage(config.getAgentAutoScaleDockerRepo()+":"+config.getAgentAutoScaleDockerTag());
        containerInfoBuilder.setDocker(dockerInfoBuider.build());

        Protos.TaskInfo.Builder taskBuilder = Protos.TaskInfo.newBuilder()
                .setName("Task"+taskId.getValue())
                .setTaskId(taskId)
                .setSlaveId(offer.getSlaveId());
        for (int i = 0; i < offer.getResourcesCount(); i++) {
            taskBuilder.addResources(offer.getResources(i));
        }
        taskBuilder.setCommand(commandBuilder.build());
        taskBuilder.setContainer(containerInfoBuilder.build());


        List<Protos.TaskInfo> tasks = new ArrayList<Protos.TaskInfo>();
        tasks.add(taskBuilder.build());

        driver.launchTasks(offer.getId(), tasks);

        return taskId;
    }

    /**
     * The main process in this function includes:
     * 1. match the attributes. If offers' attributes include the configuring slaveAttributes, the offer can be used.
     * 2. read the first request from the requests. create the task. store the task ID into results.
     * 3. calculate mesosMaxAgentCount. It means all matched offers except being used.
     *
     * @param driver MesosSchedulerDriver
     * @param offers offer list
     */
    @Override
    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {

        mesosAllowedAgentCount = 0;
        calculateMesosAllowedAgentCountTimeStamp = System.currentTimeMillis();

        for(Protos.Offer offer:offers){
            if (matchAttributes(offer)) {
                if (requests.keySet().iterator().hasNext()) {
                    String testId = requests.keySet().iterator().next();
                    int requiredAgent = requests.get(testId);

                    Protos.TaskID taskId = createMesosTask(offer, testId);

                    if (results.get(testId) == null) {
                        results.put(testId, new Result());
                    }
                    else {
                        results.get(testId).setSchedulerTime(System.currentTimeMillis());
                    }
                    results.get(testId).getTasksOfPerfTest().add(taskId);

                    if (requiredAgent == 1) {
                        operateRequets(Operation.REMOVE, testId, -1);
                    }
                    else {
                        requiredAgent--;
                        operateRequets(Operation.ADD, testId, requiredAgent);
                    }

                    continue;
                }

                //This offer is matched and don't use this time. It can be used next time.
                mesosAllowedAgentCount++;
                driver.declineOffer(offer.getId());
            }
            else {
                //This offer is not matched. Don't send us again in 10 mins.
                Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(10*60).build();
                driver.declineOffer(offer.getId(), filters);
            }

        }
    }

    @Override
    public void offerRescinded(SchedulerDriver driver, Protos.OfferID offerId) {
        LOG.debug("Rescinded offer " + offerId.getValue());
    }

    @Override
    public void statusUpdate(SchedulerDriver driver, Protos.TaskStatus status) {
        Protos.TaskID taskId = status.getTaskId();
        Protos.TaskState taskState = status.getState();

        LOG.debug("Received state update, task id = {}, task state = {}", taskId.getValue(), taskState.toString());
    }

    @Override
    public void frameworkMessage(SchedulerDriver driver, Protos.ExecutorID executorId,
                                 Protos.SlaveID slaveId, byte[] data) {
        LOG.debug("Received framework message from executor " + executorId.getValue()
                + " of slave " + slaveId.getValue());
    }

    @Override
    public void slaveLost(SchedulerDriver driver, Protos.SlaveID slaveId) {
        LOG.debug("Slave " + slaveId.getValue() + " lost!");
    }

    @Override
    public void executorLost(SchedulerDriver driver, Protos.ExecutorID executorId,
                             Protos.SlaveID slaveId, int status) {
        LOG.debug("Executor " + executorId.getValue() + " of slave " + slaveId.getValue() + " lost!");
    }

    @Override
    public void error(SchedulerDriver driver, String message) {
        LOG.error(message);
    }

    /**
     * When the perfTest is finished, remove all related agents by killing mesos task.
     *
     * @param perfTestId perfTestIdentifier
     */
    public void removeAgents(String perfTestId){
        if (!isMesosFrameworkStarted()) {
            return;
        }

        if (requests.get(perfTestId) != null)
            operateRequets(Operation.REMOVE, perfTestId, -1);

        if (results.get(perfTestId) == null)
            return;

        for(Protos.TaskID taskId:results.get(perfTestId).getTasksOfPerfTest()){
            driver.killTask(taskId);
        }

        results.remove(perfTestId);
    }

    /**
     * If the test case is not included in database, remove all related agents.
     *
     */
    public void removeHangUpAgent() {

        Iterator iterator = results.keySet().iterator();

        while(iterator.hasNext()) {
            String testId = iterator.next().toString();
            if (isPerfTestExit(testId)) {
                removeAgents(testId);
            }
        }

    }

    /**
     * The class is used to record the task info.
     */
    class Result {
        private long schedulerTime;
        private List<Protos.TaskID> tasksOfPerTest;

        Result() {
            schedulerTime = System.currentTimeMillis();
            tasksOfPerTest = new ArrayList<Protos.TaskID>();
        }

        public long getSchedulerTime(){
            return schedulerTime;
        }
        public void setSchedulerTime(long time){
            schedulerTime = time;
        }
        public List<Protos.TaskID> getTasksOfPerfTest(){
            return tasksOfPerTest;
        }
    }

    /**
     * Make sure only one thread can operate Requests at one time.
     *
     * @param opt Operation.ADD or Operation.REMOVE
     * @param id perfTestIdentifier
     * @param count required Agent count
     */
    private synchronized void operateRequets(Operation opt, String id, int count) {
        switch (opt) {
            case ADD:
                requests.put(id, count);
                break;

            case REMOVE:
                requests.remove(id);
                break;

            default:
                LOG.error("The operation type is not matched for Requests!");
                break;
        }
    }

    enum Operation {
        ADD,
        REMOVE,
    }
}
